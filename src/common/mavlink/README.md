### Общий мавлинк

В этом каталоге хранятся определения сообщений и генерат для мавлинка, используемого по всей системе.

**Для работы с pymavlink в любой её части нужны модули lxml и future**. Их следует установить в (v)env, в котором вы собираетесь работать.


## Использование в проекте на Си

**TLDR:**

1. правьте определения сообщений в `./message_definitions/v1.0/its.xml`;
2. запускайте скрипт `./regenerate-cmavlink.sh`;
3. используйте генерат из `./generated.mavlink` через симлинк или _include-directories_.


Для использования мавлинка в бортовом или наземном проекте на Си нужно сгенерировать сишный код. Это делается при помощи команды навроде `python3 -m pymavlink.tools.mavgen	-o <путь до выходной папки> --lang=C --wire-protocol=2.0 <путь до .xml определения сообщений>`. При этом pymavlnik не обязательно устанавливать и можно использовать каталог его исходников прямо как он есть, если он есть в PYTHONPATH (а рабочий каталог терминала тоже входит в PYTHONPATH).


Для большего удобства в этом каталоге расположен скрипт `regenerate_cmavlink.sh`. Этот скрипт удаляет каталог `./generated` из этого подкаталога и создает его заново, заполняя его генератом из `its.xml`. В результате работе скрипта в каталоге `./generated/mavlink` будет актуальная версия сишного кода для сообщений из `.message_definitions/v1.0/its.xml`.


Если вы хотите использовать его в своём бортовом проекте, то следует создать симлинк в дереве исходников своего проекта на
каталог `./generated/mavlink`, или добавить этот каталог в список _include-directories_.


## Использование в проекте на Python

**TLDR:**

1. правьте определения сообщений в `./message_definitions/v1.0/its.xml`;
2. активируйте целевой venv (или не активируйте, если не нужен);
3. запускайте скрипт `./reinstall-pymavlink.sh`;
4. в своём проекте определите переменную окружения `MAVLINK_DIALECT=its` для выбора нужного диалекта в mavutil;
5. используйте `pymavlnik.mavutil` из целевого venv или сами сообщения из `pymavlink.dialects.v20.its`.


Самый безболезненный способ использования pymavlink с кастомным набором сообщений (а это как раз наш случай) - это сборка пакета и его установка в целевой интерпретатор (рекомендуется venv).

Собрать .whl для pymavlink можно при помощи команды `python setup.py bdist_wheel`, выполненной из каталога `./pymavlink`. При сборке, pymavlink по-умолчанию ищет .xml определения сообщений по путям при помощи такого кода:

```python
    if os.getenv("MDEF",None) is not None:
        mdef_paths = [os.getenv("MDEF")]
    else:
        mdef_paths = [os.path.join('..', 'message_definitions'),
                      os.path.join('mavlink', 'message_definitions'),
                      os.path.join('..', 'mavlink', 'message_definitions'),
                      os.path.join('message_definitions'),
```

То есть, наш каталог `../message_definitions` будет использован первым и явно указывать через `export MDEF=...` не нужно.

После сборки .whl файл будет расположен по пути `./pymavlink/dist/pymavink****.whl`. Оттуда его можно установить через `pip install -U <.whl> файл`. При этом установлено все в будет текущий (v)env питона. Если во время сборки сыпется кучу предупреждений - значит у Вас не стоит `lxml`!

Для удобства есть скрипт `./reinstall-pymavlink.h`, который удаляет результаты предидущей сборки, собирает .whl файл и устанавливает его в текущий (v)env.

P.S Вроде бы такого не было замечено в текущей верссии, но иногда бывало, что сборщик использовал кешированные определения сообщений из `./pymavlink/dialects/...`. В таком случае можно сделать `git clean -dfx` в каталоге `./pymavlnik` - это удалит все неотслеживаемые гитом файлы.